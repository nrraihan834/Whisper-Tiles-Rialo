<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Whisper Tiles — Rialo</title>
  <style>
    :root {
      --logo-url: url('https://pbs.twimg.com/profile_images/1950265537784926208/qbjSWMDP_400x400.jpg');
      --bg: #07020c;
      --fg: #e7e3dc;
      --cyan: #00ffff;
      --accent: #b884ff;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 700px at 50% -10%, #201330 0%, #0d0816 35%, var(--bg) 70%);
      color: var(--fg);
      font-family: 'Cinzel', serif;
      display: grid;
      place-items: center;
    }
    .wrap { width: min(92vw, 840px); text-align: center; }
    h1 { margin: .25rem 0 0; letter-spacing: 1px; font-weight: 700; }
    .sub { opacity: .8; margin: .25rem 0 1rem; font-size: .95rem; }

    .hud { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; align-items: center; margin: .5rem 0 1rem; }
    .pill { border: 1px solid #2b2b36; padding: .35rem .7rem; border-radius: 999px; background: #111019; box-shadow: inset 0 0 12px #0b0b14; }
    .pill strong { color: var(--cyan); }

    #grid { display: grid; gap: 12px; justify-content: center; margin: 0 auto 1rem; }

    .tile {
      position: relative;
      width: 84px;
      aspect-ratio: 1/1;
      border-radius: 14px;
      background: rgba(0, 255, 255, .06);
      border: 1px solid rgba(0, 255, 255, .18);
      box-shadow: 0 0 0 0 rgba(0, 255, 255, .0), inset 0 0 24px rgba(0, 0, 0, .35);
      cursor: pointer;
      transition: transform .14s ease, box-shadow .2s ease, background .2s ease, border-color .2s ease, filter .2s ease;
      overflow: hidden;
    }
    .tile::before {
      content: "";
      position: absolute;
      inset: 12% 12% 12% 12%;
      background-image: var(--logo-url);
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      opacity: .65;
      filter: grayscale(1) contrast(1.05);
      transition: opacity .25s ease, filter .25s ease, transform .2s ease;
    }
    .tile.reveal {
      background: radial-gradient(120% 120% at 50% 40%, rgba(0, 255, 255, .45), rgba(0, 255, 255, .12) 55%, transparent 60%);
      border-color: rgba(0, 255, 255, .6);
      box-shadow: 0 0 24px 6px rgba(0, 255, 255, .35), inset 0 0 40px rgba(0, 255, 255, .25);
    }
    .tile.reveal::before {
      opacity: 1;
      filter: grayscale(0) drop-shadow(0 0 8px rgba(0, 255, 255, .6));
      transform: scale(1.04);
    }

    .tile.clicked { transform: scale(.96); }
    .tile.good { box-shadow: 0 0 22px 8px rgba(113, 255, 167, .35); border-color: rgba(113, 255, 167, .7); }
    .tile.bad { box-shadow: 0 0 22px 8px rgba(255, 94, 126, .35); border-color: rgba(255, 94, 126, .7); }

    .btn {
      --glow: var(--cyan);
      appearance: none;
      border: 0;
      cursor: pointer;
      font: inherit;
      color: #0b1020;
      background: linear-gradient(90deg, var(--glow), #9cf3ff);
      padding: .8rem 1.2rem;
      border-radius: 12px;
      font-weight: 700;
      letter-spacing: .2px;
      box-shadow: 0 8px 26px rgba(0, 255, 255, .25), 0 0 24px rgba(0, 255, 255, .15) inset;
      transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
    }
    .btn:hover { transform: translateY(-1px); }
    .btn:active { transform: translateY(0) scale(.98); }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Whisper Tiles</h1>
    <div class="sub">Memorize the glowing sequence, then repeat it. (Rialo Edition)</div>

    <div class="hud">
      <div class="pill">Level: <strong id="level">1</strong></div>
      <div class="pill">Grid: <strong id="gridSize">3 × 3</strong></div>
      <div class="pill">Streak: <strong id="streak">0</strong></div>
    </div>

    <div id="grid"></div>
    <p id="message">Click Start to begin.</p>
    <button id="startBtn" class="btn">Start</button>
  </div>

  <script>
    const START_GRID = 3;
    const REVEAL_MS = 650;
    const STEP_PAUSE = 220;
    const NEXT_DELAY = 750;
    const GROW_EVERY = 3;

    let gridSize = START_GRID;
    let level = 1;
    let sequence = [];
    let input = [];
    let accepting = false;
    let streak = 0;

    const gridEl = document.getElementById('grid');
    const levelEl = document.getElementById('level');
    const sizeEl = document.getElementById('gridSize');
    const streakEl = document.getElementById('streak');
    const msgEl = document.getElementById('message');
    const startBtn = document.getElementById('startBtn');

    startBtn.addEventListener('click', startGame);

    function startGame() {
      level = 1;
      gridSize = START_GRID;
      sequence = [];
      input = [];
      streak = 0;
      updateHud();
      buildGrid();
      nextLevel();
    }

    function updateHud() {
      levelEl.textContent = level;
      sizeEl.textContent = `${gridSize} × ${gridSize}`;
      streakEl.textContent = streak;
    }

    function buildGrid() {
      gridEl.innerHTML = '';
      gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 84px)`;
      const total = gridSize * gridSize;
      for (let i = 0; i < total; i++) {
        const tile = document.createElement('button');
        tile.className = 'tile';
        tile.type = 'button';
        tile.dataset.index = i;
        tile.addEventListener('click', () => onTileClick(i, tile));
        gridEl.appendChild(tile);
      }
    }

    function nextLevel() {
      accepting = false;
      input = [];
      msgEl.textContent = `Memorize…`;

      if (level > 1 && (level - 1) % GROW_EVERY === 0) {
        gridSize = Math.min(gridSize + 1, 7);
        buildGrid();
        updateHud();
      }

      const total = gridSize * gridSize;
      const next = Math.floor(Math.random() * total);
      sequence.push(next);

      revealSequence().then(() => {
        accepting = true;
        msgEl.textContent = 'Your turn…';
      });
    }

    async function revealSequence() {
      const buttons = [...gridEl.children];
      for (const idx of sequence) {
        const tile = buttons[idx];
        tile.classList.add('reveal');
        await sleep(REVEAL_MS);
        tile.classList.remove('reveal');
        await sleep(STEP_PAUSE);
      }
    }

    function onTileClick(index, el) {
      if (!accepting) return;
      flash(el);
      input.push(index);
      const expected = sequence[input.length - 1];
      if (index !== expected) {
        el.classList.add('bad');
        accepting = false;
        streak = 0;
        updateHud();
        msgEl.textContent = `❌ Wrong tile. Reached level ${level}.`;
        startBtn.textContent = 'Try Again';
        startBtn.style.setProperty('--glow', '#ff89a3');
        startBtn.style.display = 'inline-block';
        return;
      }

      el.classList.add('good');
      if (input.length === sequence.length) {
        accepting = false;
        level++;
        streak++;
        updateHud();
        msgEl.textContent = '✅ Nice! Preparing next sequence…';
        setTimeout(() => {
          [...gridEl.children].forEach(b => b.classList.remove('good', 'bad', 'clicked'));
          nextLevel();
        }, NEXT_DELAY);
      }
    }

    function flash(el) {
      el.classList.remove('clicked');
      void el.offsetWidth;
      el.classList.add('clicked');
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
  </script>
</body>
</html>
