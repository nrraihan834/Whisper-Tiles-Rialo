<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Whisper Tiles — Rialo (Flip + Sound + Highscore)</title>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --logo-url: url('https://pbs.twimg.com/profile_images/1950265537784926208/qbjSWMDP_400x400.jpg');
    --bg:#07020c; --fg:#e7e3dc; --cyan:#00ffff; --good:#71ffa7; --bad:#ff5e7e;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 700px at 50% -10%, #201330 0%, #0d0816 35%, var(--bg) 70%);
    color:var(--fg); font-family:'Cinzel',serif; display:grid; place-items:center;
  }
  .wrap{width:min(96vw,920px); text-align:center}
  h1{margin:.25rem 0 0}
  .sub{opacity:.85; margin:.25rem 0 1rem}

  .hud{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin:.5rem 0 1rem}
  .pill{border:1px solid #2b2b36;padding:.35rem .7rem;border-radius:999px;background:#111019;box-shadow:inset 0 0 12px #0b0b14}
  .pill strong{color:var(--cyan)}

  #grid{display:grid;gap:14px;justify-content:center;margin:0 auto 1rem}

  /* --- Card 3D flip --- */
  .card{width:90px;aspect-ratio:1;border-radius:14px;perspective:800px}
  .inner{
    position:relative;width:100%;height:100%;transform-style:preserve-3d;
    transition:transform .45s cubic-bezier(.2,.8,.2,1);
  }
  .card.flipped .inner{transform:rotateY(180deg)}
  .face{
    position:absolute; inset:0; border-radius:14px; backface-visibility:hidden; overflow:hidden;
    border:1px solid rgba(0,255,255,.18); box-shadow:inset 0 0 24px rgba(0,0,0,.35);
  }
  /* back (hidden) */
  .back{ background:#000; }
  .back::after{
    content:""; position:absolute; inset:0;
    background:linear-gradient(180deg, rgba(0,255,255,.08), transparent 35%),
               radial-gradient(120% 80% at 50% 0%, rgba(0,255,255,.08), transparent 60%);
    pointer-events:none;
  }
  /* front (revealed) */
  .front{ transform:rotateY(180deg); display:grid; place-items:center; background:#080a10; }
  .front .logo{
    width:70%; height:70%; background-image:var(--logo-url);
    background-size:cover; background-position:center; border-radius:12px;
    filter:drop-shadow(0 0 10px rgba(0,255,255,.6));
  }
  .front .wrong{
    width:64%; aspect-ratio:1; border-radius:10px; display:grid; place-items:center;
    background:rgba(255,94,126,.08); border:2px solid var(--bad);
    box-shadow:0 0 18px rgba(255,94,126,.35), inset 0 0 30px rgba(255,94,126,.15);
    font-weight:700; color:#fff; text-shadow:0 0 10px rgba(255,94,126,.7);
  }
  .front .wrong::before{ content:"✖"; font-size:48px; line-height:1; }

  /* reveal signal (no flip) */
  .signal .back{
    box-shadow:0 0 24px 6px rgba(0,255,255,.35), inset 0 0 40px rgba(0,255,255,.25);
    border-color:rgba(0,255,255,.6);
    animation:pulse .6s ease-in-out;
  }
  @keyframes pulse{0%{filter:brightness(1)}50%{filter:brightness(1.4)}100%{filter:brightness(1)}}

  .card.clickfx .back{transform:scale(.98)}

  .btn{
    --glow: var(--cyan);
    appearance:none;border:0;cursor:pointer;font:inherit;color:#0b1020;
    background:linear-gradient(90deg,var(--glow),#9cf3ff);
    padding:.8rem 1.2rem;border-radius:12px;font-weight:700;letter-spacing:.2px;
    box-shadow:0 8px 26px rgba(0,255,255,.25), 0 0 24px rgba(0,255,255,.15) inset;
    transition:transform .12s ease;
  }
  .btn:hover{transform:translateY(-1px)}
  .btn:active{transform:translateY(0) scale(.98)}
</style>
</head>
<body>
  <div class="wrap" role="application" aria-label="Whisper Tiles flip memory game">
    <h1>Whisper Tiles — Flip Edition</h1>
    <div class="sub">All cards are hidden. Watch the signal, then flip the right ones. Rialo-style ✨</div>

    <div class="hud" aria-live="polite">
      <div class="pill">Level: <strong id="level">1</strong></div>
      <div class="pill">Grid: <strong id="gridSize">3 × 3</strong></div>
      <div class="pill">Streak: <strong id="streak">0</strong></div>
      <div class="pill">Best Lvl: <strong id="bestLevel">0</strong></div>
      <div class="pill">Best Streak: <strong id="bestStreak">0</strong></div>
    </div>

    <div id="grid" aria-label="Tile grid"></div>
    <p id="message">Press Start to begin.</p>
    <button id="startBtn" class="btn">Start</button>
  </div>

<script>
/* ===== Config ===== */
const START_GRID = 3;
const REVEAL_MS  = 650;   // signal glow duration
const STEP_PAUSE = 220;   // pause between signals
const NEXT_DELAY = 800;   // delay before next round
const GROW_EVERY = 3;     // grow grid every N levels
const MAX_GRID   = 7;

/* ===== Audio (WebAudio beeps, no files needed) ===== */
let actx;
function ensureAudio(){
  if(!actx){
    actx = new (window.AudioContext||window.webkitAudioContext)();
  }
}
function tone({freq=440, dur=0.15, type='sine', gain=0.05, attack=0.005, release=0.08}){
  if(!actx) return;
  const t0 = actx.currentTime;
  const osc = actx.createOscillator();
  const g   = actx.createGain();
  osc.type = type; osc.frequency.value = freq;
  g.gain.setValueAtTime(0, t0);
  g.gain.linearRampToValueAtTime(gain, t0+attack);
  g.gain.exponentialRampToValueAtTime(0.0001, t0+attack+Math.max(0,dur-attack)+release);
  osc.connect(g).connect(actx.destination);
  osc.start(t0);
  osc.stop(t0+dur+release+0.05);
}
function chime(){ // soft two-note
  ensureAudio();
  tone({freq:880, dur:0.12, type:'sine', gain:0.05});
  setTimeout(()=>tone({freq:1320, dur:0.12, type:'sine', gain:0.05}), 90);
}
function pop(){ // correct click
  ensureAudio();
  tone({freq:600, dur:0.09, type:'triangle', gain:0.05});
}
function buzz(){ // wrong
  ensureAudio();
  // low, slightly rough
  tone({freq:140, dur:0.28, type:'square', gain:0.06});
}

/* ===== Highscore (localStorage) ===== */
const LS_LEVEL  = 'WT_bestLevel';
const LS_STREAK = 'WT_bestStreak';
let bestLevel  = parseInt(localStorage.getItem(LS_LEVEL)  || '0', 10);
let bestStreak = parseInt(localStorage.getItem(LS_STREAK) || '0', 10);

/* ===== State ===== */
let gridSize = START_GRID;
let level = 1;
let sequence = [];     // array of indexes (the correct sequence)
let input = [];        // player's current input
let accepting = false;
let streak = 0;

const gridEl     = document.getElementById('grid');
const levelEl    = document.getElementById('level');
const sizeEl     = document.getElementById('gridSize');
const streakEl   = document.getElementById('streak');
const bestLvlEl  = document.getElementById('bestLevel');
const bestStrEl  = document.getElementById('bestStreak');
const msgEl      = document.getElementById('message');
const startBtn   = document.getElementById('startBtn');

bestLvlEl.textContent = bestLevel;
bestStrEl.textContent = bestStreak;

startBtn.addEventListener('click', startGame);
document.addEventListener('pointerdown', ensureAudio); // unlock audio on first interaction
document.addEventListener('keydown', ensureAudio);

function startGame(){
  level = 1; gridSize = START_GRID; sequence = []; input = []; streak = 0;
  updateHud();
  buildGrid();
  nextLevel();
}

function updateHud(){
  levelEl.textContent = level;
  sizeEl.textContent  = `${gridSize} × ${gridSize}`;
  streakEl.textContent = streak;
  bestLvlEl.textContent = bestLevel;
  bestStrEl.textContent = bestStreak;
}

function buildGrid(){
  gridEl.innerHTML = '';
  gridEl.style.gridTemplateColumns = `repeat(${gridSize}, 90px)`;
  const total = gridSize * gridSize;
  for(let i=0;i<total;i++){
    const card = makeCard(i);
    gridEl.appendChild(card);
  }
}

function makeCard(index){
  const card = document.createElement('button');
  card.className = 'card';
  card.type = 'button';
  card.dataset.index = index;

  const inner = document.createElement('div');
  inner.className = 'inner';

  const back = document.createElement('div');
  back.className = 'face back';
  const front = document.createElement('div');
  front.className = 'face front';

  inner.appendChild(back);
  inner.appendChild(front);
  card.appendChild(inner);

  card.addEventListener('click', () => onCardClick(index, card));
  return card;
}

async function nextLevel(){
  accepting = false; input = [];
  msgEl.textContent = 'Watch the signals…';

  if(level > 1 && (level-1) % GROW_EVERY === 0){
    gridSize = Math.min(gridSize + 1, MAX_GRID);
    buildGrid(); updateHud();
  }

  const total = gridSize * gridSize;
  sequence.push(Math.floor(Math.random()*total));

  await revealSequence();

  accepting = true;
  msgEl.textContent = 'Your turn — flip the right card.';
}

async function revealSequence(){
  const cards = [...gridEl.children];
  for(const idx of sequence){
    const card = cards[idx];
    card.classList.add('signal');
    chime();
    await sleep(REVEAL_MS);
    card.classList.remove('signal');
    await sleep(STEP_PAUSE);
  }
}

function onCardClick(index, card){
  if(!accepting) return;

  card.classList.remove('clickfx'); void card.offsetWidth; card.classList.add('clickfx');

  input.push(index);
  const expected = sequence[input.length - 1];
  const isCorrect = index === expected;

  const front = card.querySelector('.front');
  front.innerHTML = '';
  const node = document.createElement('div');
  node.className = isCorrect ? 'logo' : 'wrong';
  front.appendChild(node);

  card.classList.add('flipped');

  if(!isCorrect){
    // WRONG -> sound + end + save best
    buzz();
    accepting = false;
    if(level-1 > bestLevel){ bestLevel = level-1; localStorage.setItem(LS_LEVEL, String(bestLevel)); }
    if(streak   > bestStreak){ bestStreak = streak; localStorage.setItem(LS_STREAK, String(bestStreak)); }
    updateHud();
    msgEl.textContent = `❌ Wrong card. You reached level ${level}.`;
    startBtn.textContent = 'Try Again';
    startBtn.style.setProperty('--glow', '#ff89a3');
    startBtn.style.display = 'inline-block';
    return;
  }

  // CORRECT -> pop
  pop();

  if(input.length === sequence.length){
    // Round complete
    accepting = false; level++; streak++; updateHud();
    msgEl.textContent = '✅ Correct! Preparing next round…';
    setTimeout(() => {
      // flip back all
      [...gridEl.children].forEach(c => {
        c.classList.remove('flipped','clickfx','signal');
        const f = c.querySelector('.front'); if(f) f.innerHTML = '';
      });
      nextLevel();
    }, NEXT_DELAY);
  }else{
    msgEl.textContent = `Good! Keep going… (${input.length}/${sequence.length})`;
  }
}

function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
</script>
</body>
</html>
